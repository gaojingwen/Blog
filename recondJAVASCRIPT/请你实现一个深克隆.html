<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试官:请你实现一个深克隆 | 小三胖技术栈</title>
    <meta name="description" content="佛系前端大神">
    <meta charset="UTF-8">
  <link rel="icon" href="/Blog/favicon.ico">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.9ba1bd5b.css" as="style"><link rel="preload" href="/Blog/assets/js/app.b624378b.js" as="script"><link rel="preload" href="/Blog/assets/js/29.443e4941.js" as="script"><link rel="prefetch" href="/Blog/assets/js/25.812a025f.js"><link rel="prefetch" href="/Blog/assets/js/2.6f79cb1b.js"><link rel="prefetch" href="/Blog/assets/js/3.d16a0c2c.js"><link rel="prefetch" href="/Blog/assets/js/4.981975ce.js"><link rel="prefetch" href="/Blog/assets/js/5.22251c73.js"><link rel="prefetch" href="/Blog/assets/js/6.628e770d.js"><link rel="prefetch" href="/Blog/assets/js/7.07e2b6b4.js"><link rel="prefetch" href="/Blog/assets/js/8.2bccae8e.js"><link rel="prefetch" href="/Blog/assets/js/9.5fab895e.js"><link rel="prefetch" href="/Blog/assets/js/10.322ce4df.js"><link rel="prefetch" href="/Blog/assets/js/11.006e4719.js"><link rel="prefetch" href="/Blog/assets/js/12.3333e057.js"><link rel="prefetch" href="/Blog/assets/js/13.1af90041.js"><link rel="prefetch" href="/Blog/assets/js/14.182c46a3.js"><link rel="prefetch" href="/Blog/assets/js/15.1cbbb4a1.js"><link rel="prefetch" href="/Blog/assets/js/16.49b9f0b6.js"><link rel="prefetch" href="/Blog/assets/js/17.29b175e7.js"><link rel="prefetch" href="/Blog/assets/js/18.297427c5.js"><link rel="prefetch" href="/Blog/assets/js/19.2663f562.js"><link rel="prefetch" href="/Blog/assets/js/20.b7420290.js"><link rel="prefetch" href="/Blog/assets/js/21.d39c8908.js"><link rel="prefetch" href="/Blog/assets/js/22.f1126d66.js"><link rel="prefetch" href="/Blog/assets/js/23.4a7a29be.js"><link rel="prefetch" href="/Blog/assets/js/24.e6bca216.js"><link rel="prefetch" href="/Blog/assets/js/26.9960f054.js"><link rel="prefetch" href="/Blog/assets/js/27.fc3fad79.js"><link rel="prefetch" href="/Blog/assets/js/28.cd83fc3d.js"><link rel="prefetch" href="/Blog/assets/js/30.6a8a17b9.js"><link rel="prefetch" href="/Blog/assets/js/31.8fc47db9.js"><link rel="prefetch" href="/Blog/assets/js/32.b715a23d.js"><link rel="prefetch" href="/Blog/assets/js/33.518efbd0.js"><link rel="prefetch" href="/Blog/assets/js/34.76e7b1b1.js"><link rel="prefetch" href="/Blog/assets/js/35.f8a6b00b.js"><link rel="prefetch" href="/Blog/assets/js/36.8c12af51.js"><link rel="prefetch" href="/Blog/assets/js/37.cda5ca1d.js"><link rel="prefetch" href="/Blog/assets/js/38.60935ef0.js"><link rel="prefetch" href="/Blog/assets/js/39.26c637dd.js"><link rel="prefetch" href="/Blog/assets/js/40.44a0bfa7.js"><link rel="prefetch" href="/Blog/assets/js/41.259d1527.js"><link rel="prefetch" href="/Blog/assets/js/42.ab80d836.js"><link rel="prefetch" href="/Blog/assets/js/43.0af190a7.js"><link rel="prefetch" href="/Blog/assets/js/44.093f7743.js"><link rel="prefetch" href="/Blog/assets/js/45.8c17580f.js"><link rel="prefetch" href="/Blog/assets/js/46.fd30eace.js"><link rel="prefetch" href="/Blog/assets/js/47.214dd0f8.js"><link rel="prefetch" href="/Blog/assets/js/48.d43dc2ae.js"><link rel="prefetch" href="/Blog/assets/js/49.6136b23c.js"><link rel="prefetch" href="/Blog/assets/js/50.fd4e81e2.js"><link rel="prefetch" href="/Blog/assets/js/51.9fa346c5.js"><link rel="prefetch" href="/Blog/assets/js/52.6e5d9385.js"><link rel="prefetch" href="/Blog/assets/js/53.19db09c4.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.9ba1bd5b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">小三胖技术栈</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/recondRESUME/" class="nav-link">Resume</a></div><div class="nav-item"><a href="/Blog/recondCSS/" class="nav-link">Css</a></div><div class="nav-item"><a href="/Blog/recondJAVASCRIPT/" class="nav-link router-link-active">Javascript</a></div><div class="nav-item"><a href="/Blog/recondVUE/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/Blog/recondNODE/" class="nav-link">Node</a></div><div class="nav-item"><a href="/Blog/recondES6/" class="nav-link">Es6</a></div><div class="nav-item"><a href="/Blog/recondPROJECT/" class="nav-link">projectify</a></div><div class="nav-item"><a href="/Blog/recondSUMMARY/" class="nav-link">summary</a></div><div class="nav-item"><a href="/Blog/recondFEATURE/" class="nav-link">feature</a></div><div class="nav-item"><a href="/Blog/recondGIT/" class="nav-link">git</a></div><div class="nav-item"><a href="/Blog/recondOTHER/" class="nav-link">other</a></div><div class="nav-item"><a href="https://github.com/gaojingwen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/recondRESUME/" class="nav-link">Resume</a></div><div class="nav-item"><a href="/Blog/recondCSS/" class="nav-link">Css</a></div><div class="nav-item"><a href="/Blog/recondJAVASCRIPT/" class="nav-link router-link-active">Javascript</a></div><div class="nav-item"><a href="/Blog/recondVUE/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/Blog/recondNODE/" class="nav-link">Node</a></div><div class="nav-item"><a href="/Blog/recondES6/" class="nav-link">Es6</a></div><div class="nav-item"><a href="/Blog/recondPROJECT/" class="nav-link">projectify</a></div><div class="nav-item"><a href="/Blog/recondSUMMARY/" class="nav-link">summary</a></div><div class="nav-item"><a href="/Blog/recondFEATURE/" class="nav-link">feature</a></div><div class="nav-item"><a href="/Blog/recondGIT/" class="nav-link">git</a></div><div class="nav-item"><a href="/Blog/recondOTHER/" class="nav-link">other</a></div><div class="nav-item"><a href="https://github.com/gaojingwen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Javascript</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Blog/recondJAVASCRIPT/" class="sidebar-link">大笨蛋</a></li><li><a href="/Blog/recondJAVASCRIPT/7分钟理解JS的节流、防抖及使用场景.html" class="sidebar-link">7分钟理解JS的节流、防抖及使用场景</a></li><li><a href="/Blog/recondJAVASCRIPT/FormData 对象的使用.html" class="sidebar-link">FormData 对象的使用</a></li><li><a href="/Blog/recondJAVASCRIPT/JavaScript 运行原理解析.html" class="sidebar-link">JavaScript 运行原理解析</a></li><li><a href="/Blog/recondJAVASCRIPT/js--API.html" class="sidebar-link">js--API</a></li><li><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html" class="sidebar-link">JS数组循环的性能和效率分析（for、while、forEach、map、for of）</a></li><li><a href="/Blog/recondJAVASCRIPT/分享前端开发常用代码片段.html" class="sidebar-link">分享前端开发常用代码片段</a></li><li><a href="/Blog/recondJAVASCRIPT/前端开发常用代码片段.html" class="sidebar-link">前端开发常用代码片段</a></li><li><a href="/Blog/recondJAVASCRIPT/深入深入再深入 js 深拷贝对象.html" class="sidebar-link">深入深入再深入 js 深拷贝对象</a></li><li><a href="/Blog/recondJAVASCRIPT/请你实现一个深克隆.html" class="active sidebar-link">面试官:请你实现一个深克隆</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="面试官-请你实现一个深克隆"><a href="#面试官-请你实现一个深克隆" aria-hidden="true" class="header-anchor">#</a> 面试官:请你实现一个深克隆</h1> <hr> <h4 id="面试官系列-2-既然react-vue可以用event-bus进行组件通信-你可以实现下吗"><a href="#面试官系列-2-既然react-vue可以用event-bus进行组件通信-你可以实现下吗" aria-hidden="true" class="header-anchor">#</a> 面试官系列(2):<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ac2fb886fb9a028b86e328c" target="_blank" rel="noopener noreferrer">既然React/Vue可以用Event Bus进行组件通信,你可以实现下吗?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <hr> <h4 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h4> <p>实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.</p> <p>我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.</p> <p>在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.</p> <p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2FElemeFE-node-interview%2Fblob%2Fmaster%2FJavaScript%25E5%259F%25BA%25E7%25A1%2580%2FJavaScript%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B.md" target="_blank" rel="noopener noreferrer">javascript基础类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <blockquote><p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol</p></blockquote> <blockquote><p>JavaScript引用类型:Object</p></blockquote> <hr> <h4 id="_1-浅克隆"><a href="#_1-浅克隆" aria-hidden="true" class="header-anchor">#</a> 1.浅克隆</h4> <p><strong>浅克隆</strong>之所以被称为<strong>浅克隆</strong>，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 浅克隆函数
function shallowClone(o) {
  const obj = {};
  for ( let i in o) {
    obj[i] = o[i];
  }
  return obj;
}
// 被克隆对象
const oldObj = {
  a: 1,
  b: [ 'e', 'f', 'g' ],
  c: { h: { i: 2 } }
};

const newObj = shallowClone(oldObj);
console.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }
console.log(oldObj.c.h === newObj.c.h); // true

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>我们可以看到,很明显虽然<code>oldObj.c.h</code>被克隆了,但是它还与<code>oldObj.c.h</code>相等,这表明他们依然指向同一段堆内存,这就造成了如果对<code>newObj.c.h</code>进行修改,也会影响<code>oldObj.c.h</code>,这就不是一版好的克隆.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>newObj.c.h.i = 'change';
console.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 'change' }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们改变了<code>newObj.c.h.i</code>的值,<code>oldObj.c.h.i</code>也被改变了,这就是浅克隆的问题所在.</p> <p>当然有一个新的api<code>Object.assign()</code>也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p> <h4 id="_2-深克隆"><a href="#_2-深克隆" aria-hidden="true" class="header-anchor">#</a> 2.深克隆</h4> <h5 id="_2-1-json-parse方法"><a href="#_2-1-json-parse方法" aria-hidden="true" class="header-anchor">#</a> 2.1 JSON.parse方法</h5> <p>前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const newObj = JSON.parse(JSON.stringify(oldObj));
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>我们依然用上一节的例子进行测试</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const oldObj = {
  a: 1,
  b: [ 'e', 'f', 'g' ],
  c: { h: { i: 2 } }
};

const newObj = JSON.parse(JSON.stringify(oldObj));
console.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }
console.log(oldObj.c.h === newObj.c.h); // false
newObj.c.h.i = 'change';
console.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 2 }

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p> <p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p> <blockquote><p>1.他无法实现对函数 、RegExp等特殊对象的克隆</p></blockquote> <blockquote><p>2.会抛弃对象的constructor,所有的构造函数会指向Object</p></blockquote> <blockquote><p>3.对象有循环引用,会报错</p></blockquote> <p>主要的坑就是以上几点,我们一一测试下.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 构造函数
function person(pname) {
  this.name = pname;
}

const Messi = new person('Messi');

// 函数
function say() {
  console.log('hi');
};

const oldObj = {
  a: say,
  b: new Array(1),
  c: new RegExp('ab+c', 'i'),
  d: Messi
};

const newObj = JSON.parse(JSON.stringify(oldObj));

// 无法复制函数
console.log(newObj.a, oldObj.a); // undefined [Function: say]
// 稀疏数组复制错误
console.log(newObj.b[0], oldObj.b[0]); // null undefined
// 无法复制正则对象
console.log(newObj.c, oldObj.c); // {} /ab+c/i
// 构造函数指向错误
console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const oldObj = {};

oldObj.a = oldObj;

const newObj = JSON.parse(JSON.stringify(oldObj));
console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>对象的循环引用会抛出错误.</p> <h5 id="_2-2-构造一个深克隆函数"><a href="#_2-2-构造一个深克隆函数" aria-hidden="true" class="header-anchor">#</a> 2.2 构造一个深克隆函数</h5> <p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的<strong>序列/反序列</strong>是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.</p> <p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626bc7a5caf947c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>(这个方法也会出现上一节提到的问题)</p> <p>由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isType = (obj, type) =&gt; {
  if (typeof obj !== 'object') return false;
  const typeString = Object.prototype.toString.call(obj);
  let flag;
  switch (type) {
    case 'Array':
      flag = typeString === '[object Array]';
      break;
    case 'Date':
      flag = typeString === '[object Date]';
      break;
    case 'RegExp':
      flag = typeString === '[object RegExp]';
      break;
    default:
      flag = false;
  }
  return flag;
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = Array.of(3, 4, 5, 2);

console.log(isType(arr, 'Array')); // true
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>对于正则对象,我们在处理之前要先补充一点新知识.</p> <p>我们需要通过<a href="https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fregex%23flags-%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener noreferrer">正则的扩展<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了解到<code>flags</code>属性等等,因此我们需要实现一个提取flags的函数.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const getRegExp = re =&gt; {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>做好了这些准备工作,我们就可以进行深克隆的实现了.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
* deep clone
* @param  {[type]} parent object 需要进行克隆的对象
* @return {[type]}        深克隆后的对象
*/
const clone = parent =&gt; {
  // 维护两个储存循环引用的数组
  const parents = [];
  const children = [];

  const _clone = parent =&gt; {
    if (parent === null) return null;
    if (typeof parent !== 'object') return parent;

    let child, proto;

    if (isType(parent, 'Array')) {
      // 对数组做特殊处理
      child = [];
    } else if (isType(parent, 'RegExp')) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (isType(parent, 'Date')) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime());
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent);
      // 利用Object.create切断原型链
      child = Object.create(proto);
    }

    // 处理循环引用
    const index = parents.indexOf(parent);

    if (index != -1) {
      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
      return children[index];
    }
    parents.push(parent);
    children.push(child);

    for (let i in parent) {
      // 递归
      child[i] = _clone(parent[i]);
    }

    return child;
  };
  return _clone(parent);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p>我们做一下测试</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function person(pname) {
  this.name = pname;
}

const Messi = new person('Messi');

function say() {
  console.log('hi');
}

const oldObj = {
  a: say,
  c: new RegExp('ab+c', 'i'),
  d: Messi,
};

oldObj.b = oldObj;


const newObj = clone(oldObj);
console.log(newObj.a, oldObj.a); // [Function: say] [Function: say]
console.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }
console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i
console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p> <hr> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>实现一个完整的深克隆是由许多坑要踩的,npm上一些库的实现也不够完整,在生产环境中最好用<code>lodash</code>的深克隆实现.</p> <p>在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道<strong>序列/反序列</strong>这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/14/2018, 5:13:48 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/Blog/assets/js/29.443e4941.js" defer></script><script src="/Blog/assets/js/app.b624378b.js" defer></script>
  </body>
</html>
