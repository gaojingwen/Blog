<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS数组循环的性能和效率分析（for、while、forEach、map、for of） | 小三胖技术栈</title>
    <meta name="description" content="佛系前端大神">
    <meta charset="UTF-8">
  <link rel="icon" href="/Blog/favicon.ico">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.9ba1bd5b.css" as="style"><link rel="preload" href="/Blog/assets/js/app.b624378b.js" as="script"><link rel="preload" href="/Blog/assets/js/22.f1126d66.js" as="script"><link rel="prefetch" href="/Blog/assets/js/25.812a025f.js"><link rel="prefetch" href="/Blog/assets/js/2.6f79cb1b.js"><link rel="prefetch" href="/Blog/assets/js/3.d16a0c2c.js"><link rel="prefetch" href="/Blog/assets/js/4.981975ce.js"><link rel="prefetch" href="/Blog/assets/js/5.22251c73.js"><link rel="prefetch" href="/Blog/assets/js/6.628e770d.js"><link rel="prefetch" href="/Blog/assets/js/7.07e2b6b4.js"><link rel="prefetch" href="/Blog/assets/js/8.2bccae8e.js"><link rel="prefetch" href="/Blog/assets/js/9.5fab895e.js"><link rel="prefetch" href="/Blog/assets/js/10.322ce4df.js"><link rel="prefetch" href="/Blog/assets/js/11.006e4719.js"><link rel="prefetch" href="/Blog/assets/js/12.3333e057.js"><link rel="prefetch" href="/Blog/assets/js/13.1af90041.js"><link rel="prefetch" href="/Blog/assets/js/14.182c46a3.js"><link rel="prefetch" href="/Blog/assets/js/15.1cbbb4a1.js"><link rel="prefetch" href="/Blog/assets/js/16.49b9f0b6.js"><link rel="prefetch" href="/Blog/assets/js/17.29b175e7.js"><link rel="prefetch" href="/Blog/assets/js/18.297427c5.js"><link rel="prefetch" href="/Blog/assets/js/19.2663f562.js"><link rel="prefetch" href="/Blog/assets/js/20.b7420290.js"><link rel="prefetch" href="/Blog/assets/js/21.d39c8908.js"><link rel="prefetch" href="/Blog/assets/js/23.4a7a29be.js"><link rel="prefetch" href="/Blog/assets/js/24.e6bca216.js"><link rel="prefetch" href="/Blog/assets/js/26.9960f054.js"><link rel="prefetch" href="/Blog/assets/js/27.fc3fad79.js"><link rel="prefetch" href="/Blog/assets/js/28.cd83fc3d.js"><link rel="prefetch" href="/Blog/assets/js/29.443e4941.js"><link rel="prefetch" href="/Blog/assets/js/30.6a8a17b9.js"><link rel="prefetch" href="/Blog/assets/js/31.8fc47db9.js"><link rel="prefetch" href="/Blog/assets/js/32.b715a23d.js"><link rel="prefetch" href="/Blog/assets/js/33.518efbd0.js"><link rel="prefetch" href="/Blog/assets/js/34.76e7b1b1.js"><link rel="prefetch" href="/Blog/assets/js/35.f8a6b00b.js"><link rel="prefetch" href="/Blog/assets/js/36.8c12af51.js"><link rel="prefetch" href="/Blog/assets/js/37.cda5ca1d.js"><link rel="prefetch" href="/Blog/assets/js/38.60935ef0.js"><link rel="prefetch" href="/Blog/assets/js/39.26c637dd.js"><link rel="prefetch" href="/Blog/assets/js/40.44a0bfa7.js"><link rel="prefetch" href="/Blog/assets/js/41.259d1527.js"><link rel="prefetch" href="/Blog/assets/js/42.ab80d836.js"><link rel="prefetch" href="/Blog/assets/js/43.0af190a7.js"><link rel="prefetch" href="/Blog/assets/js/44.093f7743.js"><link rel="prefetch" href="/Blog/assets/js/45.8c17580f.js"><link rel="prefetch" href="/Blog/assets/js/46.fd30eace.js"><link rel="prefetch" href="/Blog/assets/js/47.214dd0f8.js"><link rel="prefetch" href="/Blog/assets/js/48.d43dc2ae.js"><link rel="prefetch" href="/Blog/assets/js/49.6136b23c.js"><link rel="prefetch" href="/Blog/assets/js/50.fd4e81e2.js"><link rel="prefetch" href="/Blog/assets/js/51.9fa346c5.js"><link rel="prefetch" href="/Blog/assets/js/52.6e5d9385.js"><link rel="prefetch" href="/Blog/assets/js/53.19db09c4.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.9ba1bd5b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">小三胖技术栈</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/recondRESUME/" class="nav-link">Resume</a></div><div class="nav-item"><a href="/Blog/recondCSS/" class="nav-link">Css</a></div><div class="nav-item"><a href="/Blog/recondJAVASCRIPT/" class="nav-link router-link-active">Javascript</a></div><div class="nav-item"><a href="/Blog/recondVUE/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/Blog/recondNODE/" class="nav-link">Node</a></div><div class="nav-item"><a href="/Blog/recondES6/" class="nav-link">Es6</a></div><div class="nav-item"><a href="/Blog/recondPROJECT/" class="nav-link">projectify</a></div><div class="nav-item"><a href="/Blog/recondSUMMARY/" class="nav-link">summary</a></div><div class="nav-item"><a href="/Blog/recondFEATURE/" class="nav-link">feature</a></div><div class="nav-item"><a href="/Blog/recondGIT/" class="nav-link">git</a></div><div class="nav-item"><a href="/Blog/recondOTHER/" class="nav-link">other</a></div><div class="nav-item"><a href="https://github.com/gaojingwen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/recondRESUME/" class="nav-link">Resume</a></div><div class="nav-item"><a href="/Blog/recondCSS/" class="nav-link">Css</a></div><div class="nav-item"><a href="/Blog/recondJAVASCRIPT/" class="nav-link router-link-active">Javascript</a></div><div class="nav-item"><a href="/Blog/recondVUE/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/Blog/recondNODE/" class="nav-link">Node</a></div><div class="nav-item"><a href="/Blog/recondES6/" class="nav-link">Es6</a></div><div class="nav-item"><a href="/Blog/recondPROJECT/" class="nav-link">projectify</a></div><div class="nav-item"><a href="/Blog/recondSUMMARY/" class="nav-link">summary</a></div><div class="nav-item"><a href="/Blog/recondFEATURE/" class="nav-link">feature</a></div><div class="nav-item"><a href="/Blog/recondGIT/" class="nav-link">git</a></div><div class="nav-item"><a href="/Blog/recondOTHER/" class="nav-link">other</a></div><div class="nav-item"><a href="https://github.com/gaojingwen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Javascript</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Blog/recondJAVASCRIPT/" class="sidebar-link">大笨蛋</a></li><li><a href="/Blog/recondJAVASCRIPT/7分钟理解JS的节流、防抖及使用场景.html" class="sidebar-link">7分钟理解JS的节流、防抖及使用场景</a></li><li><a href="/Blog/recondJAVASCRIPT/FormData 对象的使用.html" class="sidebar-link">FormData 对象的使用</a></li><li><a href="/Blog/recondJAVASCRIPT/JavaScript 运行原理解析.html" class="sidebar-link">JavaScript 运行原理解析</a></li><li><a href="/Blog/recondJAVASCRIPT/js--API.html" class="sidebar-link">js--API</a></li><li><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html" class="active sidebar-link">JS数组循环的性能和效率分析（for、while、forEach、map、for of）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html#从最简单的for循环说起" class="sidebar-link">从最简单的for循环说起</a></li><li class="sidebar-sub-header"><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html#while循环以及es6-的新语法foreach、map和for-of，会更快吗？" class="sidebar-link">while循环以及ES6+的新语法forEach、map和for of，会更快吗？</a></li><li class="sidebar-sub-header"><a href="/Blog/recondJAVASCRIPT/JS数组循环的性能和效率分析（for、while、forEach、map、for of）.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/Blog/recondJAVASCRIPT/分享前端开发常用代码片段.html" class="sidebar-link">分享前端开发常用代码片段</a></li><li><a href="/Blog/recondJAVASCRIPT/前端开发常用代码片段.html" class="sidebar-link">前端开发常用代码片段</a></li><li><a href="/Blog/recondJAVASCRIPT/深入深入再深入 js 深拷贝对象.html" class="sidebar-link">深入深入再深入 js 深拷贝对象</a></li><li><a href="/Blog/recondJAVASCRIPT/请你实现一个深克隆.html" class="sidebar-link">面试官:请你实现一个深克隆</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="js数组循环的性能和效率分析（for、while、foreach、map、for-of）"><a href="#js数组循环的性能和效率分析（for、while、foreach、map、for-of）" aria-hidden="true" class="header-anchor">#</a> JS数组循环的性能和效率分析（for、while、forEach、map、for of）</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>前端开发中经常涉及到数组的相关操作：去重、过滤、求和、数据二次处理等等。都需要我们对数组进行循环。为了满足各种需求，JS除了提供最简单的<code>for</code>循环，在<code>ES6</code>和后续版本中也新增的诸如：<code>map、filter、some、reduce</code>等实用的方法。因为各个方法作用不同，简单的对所有涉及到循环的方法进行执行速度比较，是不公平的，也是毫无意义的。那么我们就针对<strong>最单纯的以取值为目的的循环</strong>进行一次性能和效率测试，用肉眼可见的方式，对JS中常见的这些数组循环方式进行一次探讨。</p> <h2 id="从最简单的for循环说起"><a href="#从最简单的for循环说起" aria-hidden="true" class="header-anchor">#</a> 从最简单的for循环说起</h2> <h4 id="for循环常见的四种写法，不啰嗦，直接上代码"><a href="#for循环常见的四种写法，不啰嗦，直接上代码" aria-hidden="true" class="header-anchor">#</a> <code>for</code>循环常见的四种写法，不啰嗦，直接上代码</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const persons = ['郑昊川', '钟忠', '高晓波', '韦贵铁', '杨俊', '宋灿']
// 方法一
for (let i = 0; i &lt; persons.length; i++) {
  console.log(persons[i])
}
// 方法二
for (let i = 0, len = persons.length; i &lt; len; i++) {
  console.log(persons[i])
}
// 方法三
for (let i = 0, person; person = persons[i]; i++) {
  console.log(person)
}
// 方法四
for (let i = persons.length; i--;) {
  console.log(persons[i])
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ol><li><p>第一种方法是最常见的方式，不解释。</p></li> <li><p>第二种方法是将<code>persons.length</code>缓存到变量<code>len</code>中,这样每次循环时就不会再读取数组的长度。</p></li> <li><p>第三种方式是将取值与判断合并，通过不停的枚举每一项来循环，直到枚举到空值则循环结束。执行顺序是：</p> <ul><li><p>第一步：先声明索引<code>i = 0</code>和变量<code>person</code></p></li> <li><p>第二步：取出数组的第<code>i</code>项<code>persons[i]</code>赋值给变量<code>person</code>并判断是否为<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FTruthy" target="_blank" rel="noopener noreferrer">Truthy<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>第三步：执行循环体，打印<code>person</code></p></li> <li><p>第四步：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>i++
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>。</p> <blockquote><p>当第二步中<code>person</code>的值不再是<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FTruthy" target="_blank" rel="noopener noreferrer">Truthy<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时，循环结束。方法三甚至可以这样写</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0, person; person = persons[i++];) {
  console.log(person)
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul></li> <li><p>第四种方法是倒序循环。执行的顺序是：</p> <ul><li><p>第一步：获取数组长度，赋值给变量<code>i</code></p></li> <li><p>第二步：判断<code>i</code>是否大于0并执行<code>i--</code></p></li> <li><p>第三步：执行循环体，打印</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>persons[i]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>，此时的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>i
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>已经</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>了</p> <blockquote><p>从后向前，直到<code>i === 0</code>为止。这种方式不仅去除了每次循环中读取数组长度的操作,而且只创建了一个变量<code>i</code>。</p></blockquote></li></ul></li></ol> <h4 id="四种for循环方式在数组浅拷贝中的性能和速度测试"><a href="#四种for循环方式在数组浅拷贝中的性能和速度测试" aria-hidden="true" class="header-anchor">#</a> 四种<code>for</code>循环方式在数组浅拷贝中的性能和速度测试</h4> <p>先造一个足够长的数组作为要拷贝的目标(如果<code>i</code>值过大，到亿级左右，可能会抛出JS堆栈跟踪的报错)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ARR_SIZE = 6666666
const hugeArr = new Array(ARR_SIZE).fill(1)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后分别用四种循环方式，把数组中的每一项取出，并添加到一个空数组中，也就是一次数组的浅拷贝。并通过<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FConsole%2Ftime" target="_blank" rel="noopener noreferrer">console.time<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FConsole%2FtimeEnd" target="_blank" rel="noopener noreferrer">console.timeEnd<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>记录每种循环方式的整体执行时间。通过<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2017%2F04%2Fmemory-leak.html" target="_blank" rel="noopener noreferrer">process.memoryUsage()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>比对执行前后内存中已用到的堆的差值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/* node环境下记录方法执行前后内存中已用到的堆的差值 */
function heapRecord(fun) {
  if (process) {
    const startHeap = process.memoryUsage().heapUsed
    fun()
    const endHeap = process.memoryUsage().heapUsed
    const heapDiff = endHeap - startHeap
    console.log('已用到的堆的差值: ', heapDiff)
  } else {
    fun()
  }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// 方法一，普通for循环
function method1() {
  var arrCopy = []
  console.time('method1')
  for (let i = 0; i &lt; hugeArr.length; i++) {
    arrCopy.push(hugeArr[i])
  }
  console.timeEnd('method1')
}
// 方法二，缓存长度
function method2() {
  var arrCopy = []
  console.time('method2')
  for (let i = 0, len = hugeArr.length; i &lt; len; i++) {
    arrCopy.push(hugeArr[i])
  }
  console.timeEnd('method2')
}
// 方法三，取值和判断合并
function method3() {
  var arrCopy = []
  console.time('method3')
  for (let i = 0, item; item = hugeArr[i]; i++) {
    arrCopy.push(item)
  }
  console.timeEnd('method3')
}
// 方法四，i--与判断合并，倒序迭代
function method4() {
  var arrCopy = []
  console.time('method4')
  for (let i = hugeArr.length; i--;) {
    arrCopy.push(hugeArr[i])
  }
  console.timeEnd('method4')
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>分别调用上述方法，每个方法重复执行12次,去除一个最大值和一个最小值，求平均值(四舍五入)，最终每个方法执行时间的结果如下表(测试机器：<code>MacBook Pro (15-inch, 2017) 处理器：2.8 GHz Intel Core i7 内存：16 GB 2133 MHz LPDDR3</code> 执行环境：<code>node v10.8.0</code>)：</p> <table><thead><tr><th>-</th> <th>方法一</th> <th>方法二</th> <th>方法三</th> <th>方法四</th></tr></thead> <tbody><tr><td>第一次</td> <td>152.201ms</td> <td>156.990ms</td> <td>152.668ms</td> <td>152.684ms</td></tr> <tr><td>第二次</td> <td>150.047ms</td> <td>159.166ms</td> <td>159.333ms</td> <td>152.455ms</td></tr> <tr><td>第三次</td> <td>155.390ms</td> <td>151.823ms</td> <td>159.365ms</td> <td>149.809ms</td></tr> <tr><td>第四次</td> <td>153.195ms</td> <td>155.994ms</td> <td>155.325ms</td> <td>150.562ms</td></tr> <tr><td>第五次</td> <td>151.823ms</td> <td>154.689ms</td> <td>156.483ms</td> <td>148.067ms</td></tr> <tr><td>第六次</td> <td>152.715ms</td> <td>154.677ms</td> <td>153.135ms</td> <td>150.787ms</td></tr> <tr><td>第七次</td> <td>152.084ms</td> <td>152.587ms</td> <td>157.458ms</td> <td>152.572ms</td></tr> <tr><td>第八次</td> <td>152.509ms</td> <td>153.781ms</td> <td>153.277ms</td> <td>152.263ms</td></tr> <tr><td>第九次</td> <td>154.363ms</td> <td>156.497ms</td> <td>151.002ms</td> <td>154.310ms</td></tr> <tr><td>第十次</td> <td>153.784ms</td> <td>155.612ms</td> <td>161.767ms</td> <td>153.487ms</td></tr> <tr><td><strong>平均耗时</strong></td> <td><strong>152.811ms</strong></td> <td><strong>155.182ms</strong></td> <td><strong>155.981ms</strong></td> <td><strong>151.700ms</strong></td></tr> <tr><td><strong>用栈差值</strong></td> <td><strong>238511136Byte</strong></td> <td><strong>238511352Byte</strong></td> <td><strong>238512048Byte</strong></td> <td><strong>238511312Byte</strong></td></tr></tbody></table> <p>意不意外？惊不惊喜？想象之中至少方法二肯定比方法一更快的！但事实并非如此，不相信眼前事实的我又测试了很多次，包括改变被拷贝的数组的长度，长度从百级到千万级。最后发现：在<code>node</code>下执行完成同一个数组的浅拷贝任务，耗时方面四种方法的差距微乎其微，有时候排序甚至略有波动。 内存占用方面：<strong>方法一 &lt; 方法四 &lt; 方法二 &lt; 方法三</strong>，但差距也很小。</p> <p><code>v8引擎</code>新版本针对<strong>对象取值</strong>等操作进行了最大限度的性能优化，所以方法二中缓存数组的长度到变量<code>len</code>中，并不会有太明显的提升。即使是百万级的数据，四种<code>for循环</code>的耗时差距也只是毫秒级，内存占用上四种for循环方式也都非常接近。在此感谢<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fuser%2F5881e022128fe100682735aa" target="_blank" rel="noopener noreferrer">YaHuiLiang<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fuser%2F58bf96c844d90400696b4c9b" target="_blank" rel="noopener noreferrer">七秒先生<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fuser%2F5aa5d7fa5188255579184954" target="_blank" rel="noopener noreferrer">戈寻谋doxP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fuser%2F57a1e90c5bbb500064ffc8c0%2Fposts" target="_blank" rel="noopener noreferrer">超级大柱子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的帮助和指正，如果大佬们有更好的见解也欢迎评论留言。</p> <p>同样是<code>v8引擎</code>的<code>谷歌浏览器</code>，测试发现四种方法也都非常接近。</p> <p>但是在<code>火狐浏览器</code>中的测试结果：<strong>方法二 ≈ 方法三 ≈ 方法四 &lt; 方法一</strong>，表明二三四这三种写法都可以在一定程度上优化<code>for循环</code></p> <p>而在<code>safari浏览器下</code>：<strong>方法四 &lt; 方法一 ≈ 方法二 ≈ 方法三</strong>，只有<strong>方法四</strong>体现出了小幅度的优化效果。</p> <h4 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h4> <p>考虑到在不同环境或浏览器下的性能和效率：</p> <p><code>推荐</code>：<strong>第四种</strong><code>i--</code>倒序循环的方式。在奇舞团的这篇文章——<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5b4da7efe51d45198f5c6234" target="_blank" rel="noopener noreferrer">嗨，送你一张Web性能优化地图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的<code>2.3 流程控制</code>小节里也略有提及这种方式。</p> <p><code>不推荐</code>：<strong>第三种</strong>方式。主要是因为当数组里存在非<code>Truthy</code>的值时，比如<code>0</code>和<code>''</code>，会导致循环直接结束。</p> <h2 id="while循环以及es6-的新语法foreach、map和for-of，会更快吗？"><a href="#while循环以及es6-的新语法foreach、map和for-of，会更快吗？" aria-hidden="true" class="header-anchor">#</a> <code>while</code>循环以及<code>ES6+的新语法forEach</code>、<code>map</code>和<code>for of</code>，会更快吗？</h2> <p>不啰嗦，实践是检验真理的唯一标准</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 方法五，while
function method5() {
  var arrCopy = []
  console.time('method5')
  let i = 0
  while (i &lt; hugeArr.length) {
    arrCopy.push(hugeArr[i++])
  }
  console.timeEnd('method5')
}
// 方法六,forEach
function method6() {
  var arrCopy = []
  console.time('method6')
  hugeArr.forEach((item) =&gt; {
    arrCopy.push(item)
  })
  console.timeEnd('method6')
}
// 方法七,map
function method7() {
  var arrCopy = []
  console.time('method7')
  arrCopy = hugeArr.map(item =&gt; item)
  console.timeEnd('method7')
}
// 方法八,for of
function method8() {
  var arrCopy = []
  console.time('method8')
  for (let item of hugeArr) {
    arrCopy.push(item)
  }
  console.timeEnd('method8')
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>测试方法同上，测试结果：</p> <table><thead><tr><th>-</th> <th>方法五</th> <th>方法六</th> <th>方法七</th> <th>方法八</th></tr></thead> <tbody><tr><td>第一次</td> <td>151.380ms</td> <td>221.332ms</td> <td>875.402ms</td> <td>240.411ms</td></tr> <tr><td>第二次</td> <td>152.031ms</td> <td>223.436ms</td> <td>877.112ms</td> <td>237.208ms</td></tr> <tr><td>第三次</td> <td>150.442ms</td> <td>221.853ms</td> <td>876.829ms</td> <td>253.744ms</td></tr> <tr><td>第四次</td> <td>151.319ms</td> <td>222.672ms</td> <td>875.270ms</td> <td>243.165ms</td></tr> <tr><td>第五次</td> <td>150.142ms</td> <td>222.953ms</td> <td>877.940ms</td> <td>237.825ms</td></tr> <tr><td>第六次</td> <td>155.226ms</td> <td>225.441ms</td> <td>879.223ms</td> <td>240.648ms</td></tr> <tr><td>第七次</td> <td>151.254ms</td> <td>219.965ms</td> <td>883.324ms</td> <td>238.197ms</td></tr> <tr><td>第八次</td> <td>151.632ms</td> <td>218.274ms</td> <td>878.331ms</td> <td>240.940ms</td></tr> <tr><td>第九次</td> <td>151.412ms</td> <td>223.189ms</td> <td>873.318ms</td> <td>256.644ms</td></tr> <tr><td>第十次</td> <td>155.563ms</td> <td>220.595ms</td> <td>881.203ms</td> <td>234.534ms</td></tr> <tr><td><strong>平均耗时</strong></td> <td><strong>152.040ms</strong></td> <td><strong>221.971ms</strong></td> <td><strong>877.795ms</strong></td> <td><strong>242.332ms</strong></td></tr> <tr><td><strong>用栈差值</strong></td> <td><strong>238511400Byte</strong></td> <td><strong>238511352Byte</strong></td> <td><strong>53887824Byte</strong></td> <td><strong>191345296Byte</strong></td></tr></tbody></table> <p>在<code>node</code>下，由上面的数据可以很明显的看出，<code>forEach</code>、<code>map</code>和<code>for of</code> 这些<code>ES6+</code>的语法并没有传统的<code>for</code>循环或者<code>while</code>循环快，特别是<code>map</code>方法。但是由于<code>map</code>有返回值，无需额外调用新数组的<code>push</code>方法，所以在执行浅拷贝任务上，内存占用很低。而<code>for of</code>语法在内存占用上也有一定的优势。顺便提一下：<code>for循环 while循环 for of 循环</code>是可以通过<code>break</code>关键字跳出的，而<code>forEach map</code>这种循环是无法跳出的。</p> <p>但是随着执行环境和浏览器的不同，这些语法在执行速度上也会出现偏差甚至反转的情况，直接看图：</p> <p><code>谷歌浏览器</code></p> <p><code>火狐浏览器</code></p> <p><code>safari浏览器下</code></p> <p>可以看出：</p> <ol><li>谷歌浏览器中<code>ES6+</code>的循环语法会普遍比传统的循环语法慢，但是火狐和safari中情况却几乎相反。</li> <li>谷歌浏览器的各种循环语法的执行耗时上差距并不大。但<code>map</code>特殊，速度明显比其他几种语法慢，而在火狐和safari中却出现了反转，<code>map</code>反而比较快！</li> <li>苹果大法好</li></ol> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>之前有听到过诸如“缓存数组长度可以提高循环效率”或者“ES6的循环语法更高效”的说法。说者无心，听者有意，事实究竟如何，实践出真知。抛开业务场景和使用便利性，单纯谈性能和效率是没有意义的。 ES6新增的诸多数组的方法确实极大的方便了前端开发，使得以往复杂或者冗长的代码，可以变得易读而且精炼，而好的<code>for</code>循环写法，在大数据量的情况下，确实也有着更好的兼容和多环境运行表现。当然本文的讨论也只是基于观察的一种总结，并没有深入底层。而随着浏览器的更新，这些方法的孰优孰劣也可能成为玄学。目前发现在<code>Chrome Canary 70.0.3513.0</code>下<code>for of</code> 会明显比<code>Chrome 68.0.3440.84</code>快。如果你有更深入的见解或者文章，也不妨在评论区分享，小弟的这篇文章也权当抛砖引玉。如果你对数组的其他循环方法的性能和效率也感兴趣，不妨自己动手试一试，也欢迎评论交流。</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/14/2018, 5:13:48 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/Blog/assets/js/22.f1126d66.js" defer></script><script src="/Blog/assets/js/app.b624378b.js" defer></script>
  </body>
</html>
